package main

import (
	"bytes"
	"fmt"
	"github.com/SirMetathyst/go-nu"
	"github.com/iancoleman/strcase"
	"log"
	"os"
	"os/exec"
	"strings"
)

func main() {

	client := nu.DefaultClient

	if err := WriteNovelTypesToFile(client); err != nil {
		log.Fatalln()
	}

	if err := WriteLanguagesToFile(client); err != nil {
		log.Fatalln()
	}

	if err := WriteTagsToFile(client); err != nil {
		log.Fatalln()
	}

	if err := WriteGenresToFile(client); err != nil {
		log.Fatalln()
	}
}

func normalisedName(n string) string {

	n = strcase.ToCamel(n)
	n = strings.Replace(n, " ", "", -1)
	n = strings.Replace(n, "-", "", -1)
	n = strings.Replace(n, "/", "", -1)
	n = strings.Replace(n, "'", "", -1)

	return n
}

func WriteLanguagesToFile(client *nu.Client) error {

	languages, err := client.Languages()
	if err != nil {
		return err
	}

	b := &bytes.Buffer{}
	WriteHeader(b, "nu")
	WriteLanguages(languages, b)

	_ = os.WriteFile("languages_generated.go", b.Bytes(), 0666)
	cmd := exec.Command("go", "fmt", "./languages_generated.go")
	return cmd.Run()
}

func WriteNovelTypesToFile(client *nu.Client) error {

	novelTypes, err := client.NovelTypes()
	if err != nil {
		return err
	}

	b := &bytes.Buffer{}
	WriteHeader(b, "nu")
	WriteNovelTypes(novelTypes, b)

	_ = os.WriteFile("novel_types_generated.go", b.Bytes(), 0666)
	cmd := exec.Command("go", "fmt", "./novel_types_generated.go")
	return cmd.Run()
}

func WriteTagsToFile(client *nu.Client) error {

	tags, err := client.Tags()
	if err != nil {
		return err
	}

	b := &bytes.Buffer{}
	WriteHeader(b, "nu")
	WriteTags(tags, b)

	_ = os.WriteFile("tags_generated.go", b.Bytes(), 0666)
	cmd := exec.Command("go", "fmt", "./tags_generated.go")
	return cmd.Run()
}

func WriteGenresToFile(client *nu.Client) error {

	genres, err := client.Genres()
	if err != nil {
		return err
	}

	b := &bytes.Buffer{}
	WriteHeader(b, "nu")
	WriteGenres(genres, b)

	_ = os.WriteFile("genres_generated.go", b.Bytes(), 0666)
	cmd := exec.Command("go", "fmt", "./genres_generated.go")
	return cmd.Run()
}

func WriteHeader(b *bytes.Buffer, packageName string) {

	//////// Header
	b.WriteString("// Code generated by nug (NovelUpdates Generator). DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))
}

func WriteNovelTypes(results []nu.NovelTypeResult, b *bytes.Buffer) {

	s := "NovelType"

	//////// Main
	b.WriteString(fmt.Sprintf("type %s string\n\n", s))
	b.WriteString(fmt.Sprintf("// %s: Total(%d)\n", s, len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", s, normalisedName(result.Name), s, result.Value))
	}
	b.WriteString(")\n\n")

	/////////// ValueTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tValueTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Value, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	//////// ToDisplayString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToTitle = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// DisplayStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tTitleTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Name, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// SlugStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tSlugTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Slug, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// ToSlugString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToSlug = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Slug))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

func WriteLanguages(results []nu.LanguageResult, b *bytes.Buffer) {

	s := "Language"

	//////// Main
	b.WriteString(fmt.Sprintf("type %s string\n\n", s))
	b.WriteString(fmt.Sprintf("// %s: Total(%d)\n", s, len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", s, normalisedName(result.Name), s, result.Value))
	}
	b.WriteString(")\n\n")

	/////////// ValueTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tValueTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Value, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	//////// ToDisplayString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToTitle = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// DisplayStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tTitleTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Name, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// SlugStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tSlugTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Slug, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// ToSlugString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToSlug = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Slug))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

func WriteGenres(results []nu.GenreResult, b *bytes.Buffer) {

	s := "Genre"

	//////// Main
	b.WriteString(fmt.Sprintf("type %s string\n\n", s))
	b.WriteString(fmt.Sprintf("// %s: Total(%d)\n", s, len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", s, normalisedName(result.Name), s, result.Value))
	}
	b.WriteString(")\n\n")

	/////////// ValueTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tValueTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Value, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	//////// ToDisplayString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToTitle = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// DisplayStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tTitleTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Name, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// SlugStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tSlugTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Slug, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// ToSlugString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToSlug = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Slug))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

func WriteTags(results []nu.TagResult, b *bytes.Buffer) {

	s := "Tag"

	//////// Main
	b.WriteString(fmt.Sprintf("type %s string\n\n", s))
	b.WriteString(fmt.Sprintf("// %s: Total(%d)\n", s, len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", s, normalisedName(result.Name), s, result.Value))
	}
	b.WriteString(")\n\n")

	/////////// ValueTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tValueTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Value, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	//////// ToDisplayString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToTitle = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// DisplayStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tTitleTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Name, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// SlugStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tSlugTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Slug, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// ToSlugString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToSlug = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Slug))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}
